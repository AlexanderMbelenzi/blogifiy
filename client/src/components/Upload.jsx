import { IKContext, IKUpload } from "imagekitio-react";
import { useRef, useState, useEffect, useCallback } from "react";
import { toast } from "react-toastify";
import { FaTimes, FaCamera, FaUpload } from "react-icons/fa";

const MAX_IMAGES = 10;

// --- ImageKit Authenticator (Keep as is, ensure it works) ---
const authenticator = async () => {
  try {
    const response = await fetch(
      `${import.meta.env.VITE_API_URL}/posts/upload-auth`
    );
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(
        `Request failed with status ${response.status}: ${errorText}`
      );
    }
    const data = await response.json();
    if (!data.signature || !data.token || !data.expire) {
        console.error("Authentication response missing fields:", data); // Log missing fields
        throw new Error("Authentication response missing required fields.");
    }
    return data;
  } catch (error) {
    console.error("Authentication request failed:", error);
    throw new Error(`Authentication failed: ${error.message}`);
  }
};

// --- Upload Component ---
// Added setIsUploading prop
const Upload = ({ type = "image", setProgress, setData, setIsUploading }) => {
  const fileInputRef = useRef(null);
  const videoRef = useRef(null);
  const [previewImages, setPreviewImages] = useState([]);
  const [cameraOpen, setCameraOpen] = useState(false);
  const [uploadQueue, setUploadQueue] = useState([]);
  // Track successful uploads count to compare with queue length
  const successfulUploadsRef = useRef(0);

  // Memoize handler
  const handleFileSelect = useCallback((files) => {
    const validFiles = Array.from(files).filter(file => file.type.startsWith(`${type}/`));

    if(validFiles.length !== files.length){
        toast.warn(`Some files were not of the expected type (${type}) and were ignored.`);
    }

    let availableSlots = MAX_IMAGES - previewImages.length;
    let selectedFiles = validFiles.slice(0, availableSlots);

    if (selectedFiles.length < validFiles.length) {
      toast.warn(`You can only upload a maximum of ${MAX_IMAGES} images.`);
    }

    if (selectedFiles.length === 0) {
        if(validFiles.length > 0 && availableSlots <= 0) toast.info("Maximum image limit reached.");
        return;
    }

    const newImagePreviews = selectedFiles.map((file) => ({
      file,
      localUrl: URL.createObjectURL(file),
      name: file.name // Keep name for removal logic
    }));

    setPreviewImages((prev) => [...prev, ...newImagePreviews]);

    // Add to queue and signal uploading start
    setUploadQueue((prev) => {
        const newQueue = [...prev, ...selectedFiles];
        if (newQueue.length > 0) {
            setIsUploading(true); // Signal start only if queue has items
            successfulUploadsRef.current = 0; // Reset success count when adding new files
        }
        return newQueue;
    });


    if (fileInputRef.current) {
        fileInputRef.current.value = "";
    }

  }, [previewImages.length, type, setIsUploading]); // Added setIsUploading dependency


  const onError = (err, file) => { // IKUpload passes the file on error too
    console.error("Upload Error:", err);
    const failedFileName = file?.name || "An image"; // Get filename if available
    const message = err?.message || `${failedFileName} upload failed! Please try removing and re-adding it.`;
    toast.error(message);
    setProgress(0); // Reset progress

    // Remove the failed file from the queue and preview
    const failedFileOriginalName = file?.originalFileName || file?.name; // Check originalFileName first
    if (failedFileOriginalName) {
        setPreviewImages((prev) => prev.filter(p => p.name !== failedFileOriginalName));
        setUploadQueue((prevQueue) => {
            const newQueue = prevQueue.filter((f) => f.name !== failedFileOriginalName);
            // If the queue becomes empty due to error, signal upload stopped
            if (newQueue.length === 0) {
                 setIsUploading(false);
            }
            return newQueue;
        });
    } else {
        // If we can't identify the file, we might be stuck. Resetting might be needed.
        // For simplicity here, just signal upload might be done, but it's incomplete.
        setIsUploading(false); // Cautiously signal end, though state might be inconsistent
    }
  };

  const onSuccess = (res) => {
    // Add successfully uploaded image URL/data
    setData((prev) => [...prev, { url: res.url, fileId: res.fileId }]);

    successfulUploadsRef.current += 1;

    // Check if all files initially added in this batch are now uploaded
    // Note: res.name might be the unique name generated by ImageKit, use originalFileName if available
    const originalFileName = res.originalFileName || res.name;

    setUploadQueue((prevQueue) => {
        const newQueue = prevQueue.filter((file) => file.name !== originalFileName);
        // Check if the queue is empty *after* this successful upload
        if (newQueue.length === 0) {
            setIsUploading(false); // Signal upload finished
            setProgress(100); // Ensure progress shows 100% at the end
            toast.success("All images uploaded successfully!"); // Single success message
        }
        return newQueue;
    });
  };

  // Progress reflects the *current single file* being uploaded by IKUpload
  const onUploadProgress = (progress, file) => { // File context is helpful
    const percent = Math.round((progress.loaded / progress.total) * 100);
    setProgress(percent);
    // console.log(`Progress for ${file.name}: ${percent}%`); // Debugging
  };


  const handlePaste = useCallback((event) => {
    const items = event.clipboardData.items;
    const files = [];
    for (const item of items) {
      if (item.kind === "file" && item.type.startsWith(`${type}/`)) {
        const file = item.getAsFile();
        if (file) files.push(file);
      }
    }
    if (files.length > 0) {
        handleFileSelect(files);
    }
  }, [handleFileSelect, type]);


  useEffect(() => {
    document.addEventListener("paste", handlePaste);
    return () => document.removeEventListener("paste", handlePaste);
  }, [handlePaste]);


  const removePreview = (indexToRemove) => {
      const removedImagePreview = previewImages[indexToRemove];

      setPreviewImages((prev) => prev.filter((_, i) => i !== indexToRemove));

      // Remove from upload queue
      setUploadQueue((prevQueue) => {
        const newQueue = prevQueue.filter((file) => file.name !== removedImagePreview.name);
        // If removing the last item, signal uploading stopped
        if (newQueue.length === 0 && prevQueue.length > 0) { // Check prevQueue length to avoid false signal on initial empty state
            setIsUploading(false);
            setProgress(0); // Reset progress if queue is cleared manually
        }
        return newQueue;
      });

      URL.revokeObjectURL(removedImagePreview.localUrl);
   };

  // --- Camera Functions (Keep as is, ensure handleFileSelect is called correctly) ---
  const openCamera = async () => { /* ... keep implementation ... */ };
  const capturePhoto = () => { /* ... ensure handleFileSelect([file]) is called ... */ };
  const closeCamera = () => { /* ... keep implementation ... */ };

  // --- Cleanup Effect (Keep as is) ---
  useEffect(() => { /* ... keep implementation ... */ }, [previewImages]);


  return (
    <IKContext
      publicKey={import.meta.env.VITE_IK_PUBLIC_KEY}
      urlEndpoint={import.meta.env.VITE_IK_URL_ENDPOINT}
      authenticator={authenticator}
    >
      {/* --- Clickable Area / Buttons / Camera Modal (Keep as is) --- */}
       <div
         className="p-4 border-2 border-dashed border-[var(--softBg4)] rounded-lg text-center cursor-pointer hover:bg-[var(--softBg2)] transition-colors"
         onClick={() => fileInputRef.current?.click()}
         role="button"
         tabIndex={0}
         onKeyPress={(e) => { if (e.key === 'Enter') fileInputRef.current?.click(); }}
       >
          <FaUpload className="mx-auto mb-2 text-xl text-[var(--softTextColor)]"/>
         {previewImages.length === 0
           ? "Click or Drag & Drop Images Here"
           : `Add more images (${previewImages.length}/${MAX_IMAGES})`}
           <span className="block text-xs text-[var(--softTextColor)]">(Or paste images)</span>
       </div>

       <input
         type="file"
         multiple
         className="hidden"
         ref={fileInputRef}
         accept={`${type}/*`}
         onChange={(e) => {
           if (e.target.files) {
             handleFileSelect(e.target.files);
           }
         }}
       />

       <div className="flex gap-2 mt-2">
         <button
           type="button"
           className="p-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition-colors disabled:opacity-50"
           onClick={() => fileInputRef.current?.click()}
           disabled={previewImages.length >= MAX_IMAGES}
         >
           Select Files
         </button>
         <button
           type="button"
           className="p-2 bg-green-500 text-white rounded flex items-center hover:bg-green-600 transition-colors disabled:opacity-50"
           onClick={openCamera}
           disabled={previewImages.length >= MAX_IMAGES}
         >
           <FaCamera className="mr-1" /> Take Photo
         </button>
       </div>

       {cameraOpen && (
         {/* ... Camera Modal JSX ... */}
       )}

       {previewImages.length > 0 && (
          <div className="mt-4 grid grid-cols-3 sm:grid-cols-4 md:grid-cols-5 lg:grid-cols-6 gap-2">
          {previewImages.map((img, index) => (
            <div key={index} className="relative group aspect-square">
              <img
                src={img.localUrl}
                alt={`Preview ${index + 1}`}
                className="w-full h-full object-cover rounded border border-[var(--softBg4)]"
              />
              <button
                type="button"
                className="absolute top-1 right-1 bg-red-600 text-white rounded-full p-1 opacity-70 group-hover:opacity-100 transition-opacity focus:opacity-100"
                onClick={() => removePreview(index)}
                aria-label="Remove image"
              >
                <FaTimes size={12}/>
              </button>
            </div>
          ))}
        </div>
       )}

      {/* --- ImageKit Upload Component (Processes the queue) --- */}
      {/* Render IKUpload only when there are files in the queue */}
      {uploadQueue.length > 0 && (
        <IKUpload
          // Key change might help ensure it remounts/re-evaluates props if queue changes drastically
          // key={uploadQueue.map(f => f.name).join('-')} // Optional: Use if needed
          files={uploadQueue} // Pass the current queue
          useUniqueFileName={true}
          onError={onError}
          onSuccess={onSuccess}
          onUploadProgress={onUploadProgress}
          // Tell ImageKit to return the original filename in the response
          responseFields={["url", "fileId", "name", "originalFileName"]}
          className="hidden"
          // folder={"/property_reviews"} // Optional
        />
      )}
    </IKContext>
  );
};

export default Upload;